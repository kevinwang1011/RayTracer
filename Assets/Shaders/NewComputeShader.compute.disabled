#pragma kernel RayTracer
#include "UnityCG.cginc"

uint NextRandom(inout uint state)
{
    state = state * 747796405 + 2891336453;
    uint result = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    result = (result >> 22) ^ result;
    return result;
}

float rand(inout uint state)
{
    return NextRandom(state) / 4294967295.0; // 2^32 - 1
}


// Random value in normal distribution (with mean=0 and sd=1)
float RandomValueNormalDistribution(inout uint state)
{
    // Thanks to https://stackoverflow.com/a/6178290
    float theta = 2 * 3.1415926 * rand(state);
    float rho = sqrt(-2 * log(rand(state)));
    return rho * cos(theta);
}

// Calculate a random direction
float3 RandomDirection(inout uint state)
{
    // Thanks to https://math.stackexchange.com/a/1585996
    float x = RandomValueNormalDistribution(state);
    float y = RandomValueNormalDistribution(state);
    float z = RandomValueNormalDistribution(state);
    return normalize(float3(x, y, z));
}

struct Triangle
{
    float3 v0, v1, v2;
    float3 n0, n1, n2;
    float2 uv0, uv1, uv2;
    int texID;
};

struct Ray
{
    float3 origin;
    float3 direction;
};

struct RayTracingMaterial
{
    float4 albedo;
    float4 emission;
    float4 specular;
    float emissionStrength;
    float smoothness;
    float specularProbability;
    int texID;
};

struct RayHit
{
    bool didHit;
    float3 position;
    float distance;
    float3 normal;
    float2 texcoord;
    RayTracingMaterial material;
};

struct MeshObject
{
    float4x4 localToWorldMatrix;
    int indices_offset;
    int indices_count;
    int texID;
    RayTracingMaterial material;
    float3 boundsMin;
    float3 boundsMax;
};

Texture2DArray _Texs; 
SamplerState sampler__Texs;

RWTexture2D<float4> Result;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;

// StructuredBuffer<MeshObject> _MeshObjects;
// StructuredBuffer<float3> _Vertices;
// StructuredBuffer<int> _Indices;
// StructuredBuffer<float3> _Normals;
// StructuredBuffer<float2> _TexCoords;

StructuredBuffer<Triangle> _Triangles;
StructuredBuffer<RayTracingMaterial> Materials;

int Frame;
uint rngState;


Ray CreateRay(float3 origin, float3 direction)
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

RayHit CreateRayHit()
{
    RayHit hit;
    hit.position = float3(0.0f, 0.0f, 0.0f);
    hit.distance = 1.#INF;
    hit.normal = float3(0.0f, 0.0f, 0.0f);
    hit.didHit = false;
    return hit;
}

bool RayBoundingBox(Ray ray, float3 boxMin, float3 boxMax)
{

    float3 invDir = 1 / ray.direction;
    float3 tMin = (boxMin - ray.origin) * invDir;
    float3 tMax = (boxMax - ray.origin) * invDir;
    float3 t1 = min(tMin, tMax);
    float3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);
    return tNear <= tFar;
};

static const float EPSILON = 1e-8;

bool IntersectTriangle_MT97(Ray ray, float3 vert0, float3 vert1, float3 vert2,
    inout float t, inout float u, inout float v, inout float3 N)
{
    // find vectors for two edges sharing vert0
    float3 edge1 = vert1 - vert0;
    float3 edge2 = vert2 - vert0;

    // begin calculating determinant - also used to calculate U parameter
    float3 pvec = cross(ray.direction, edge2);

    // if determinant is near zero, ray lies in plane of triangle
    float det = dot(edge1, pvec);

    // use backface culling
    if (det < EPSILON)
        return false;
    float inv_det = 1.0f / det;

    // calculate distance from vert0 to ray origin
    float3 tvec = ray.origin - vert0;

    // calculate U parameter and test bounds
    u = dot(tvec, pvec) * inv_det;
    if (u < 0.0 || u > 1.0f)
        return false;

    // prepare to test V parameter
    float3 qvec = cross(tvec, edge1);

    // calculate V parameter and test bounds
    v = dot(ray.direction, qvec) * inv_det;
    if (v < 0.0 || u + v > 1.0f)
        return false;

    // calculate t, ray intersects triangle
    t = dot(edge2, qvec) * inv_det;
    N = normalize(cross(edge1, edge2));
    return true;
}

void IntersectMeshObject(Ray ray, inout RayHit bestHit, MeshObject meshObject)
{
    uint offset = meshObject.indices_offset;
    uint count = offset + meshObject.indices_count;
    for (uint i = offset; i < count; i += 3)
    {
        float3 v0 = _Vertices[_Indices[i]];
        float3 v1 = _Vertices[_Indices[i + 1]];
        float3 v2 = _Vertices[_Indices[i + 2]];

        float t, u, v;
        float3 N;
        if(IntersectTriangle_MT97(ray, v0, v1, v2, t, u, v, N))
        {
            if (t > 0 && t < bestHit.distance)
            {
                bestHit.didHit = true;
                bestHit.distance = t;
                bestHit.position = ray.origin + t * ray.direction;
                bestHit.normal = normalize(N);
                bestHit.material = meshObject.material;
                if(meshObject.texID >= 0)
                {
                    float2 uv0 = _TexCoords[_Indices[i]].xy;
                    float2 uv1 = _TexCoords[_Indices[i + 1]].xy;
                    float2 uv2 = _TexCoords[_Indices[i + 2]].xy;

                    float2 uvec = uv1 - uv0;
                    float2 vvec = uv2 - uv0;
                    float2 uv = uv0 + u * uvec + v * vvec;

                    bestHit.texcoord = uv; 
                }
            }
        }
    }
}

float3 Trace(Ray ray, inout uint rngState)
{
    uint MAX_BOUNCES = 3;
	// Trace and shade the ray
	float3 incomingLight = 0;
	float3 rayColor = 1;

	for (int i = 0; i < MAX_BOUNCES; i++)
	{
        RayHit hit = CreateRayHit();
        uint count, stride;
        // Trace mesh objects
        _MeshObjects.GetDimensions(count, stride);
        for (int j = 0; j < count; j++)
        {
            if (!RayBoundingBox(ray, _MeshObjects[j].boundsMin, _MeshObjects[j].boundsMax))
            {
                continue;
            }
            IntersectMeshObject(ray, hit, _MeshObjects[j]);
        }

        // return float3(AABBCount / count, 0, (hit.material.texID + 1) / 4.0);

		if (hit.didHit)
        {
            RayTracingMaterial material = hit.material;
            // Handle special material types:
            // if (material.flag == 2 && i == 0)
            // {
            //     ray.origin = hit.position + ray.direction * 0.001;
            //     continue;
            // }

            // Figure out new ray position and direction
            bool isSpecularBounce = material.specularProbability >= rand(rngState);
        
            ray.origin = hit.position;
            float3 diffuseDir = normalize(hit.normal + RandomDirection(rngState));
            // ray.direction = diffuseDir;
            float3 specularDir = reflect(ray.direction, hit.normal);
            ray.direction = normalize(lerp(diffuseDir, specularDir, material.smoothness * isSpecularBounce));

            // Update light calculations
            float3 emittedLight = material.emission * material.emissionStrength;
            incomingLight += emittedLight * rayColor;
            
            float3 albedo = material.albedo;
            if(material.texID >= 0)
                albedo *= _Texs.SampleLevel(sampler__Texs, float3(hit.texcoord, material.texID), 0).xyz;
            
            // rayColor *= albedo;
            rayColor *= lerp(albedo, material.specular, isSpecularBounce);
            

            // Russian Roulette
            // Random early exit if ray color is nearly 0 (can't contribute much to final result)
            float p = max(rayColor.r, max(rayColor.g, rayColor.b));
            if (rand(rngState) >= p) {
                break;
            }
            rayColor *= 1.0f / p; 
            // incomingLight = rayColor;
        }
        else
        {
            // ambient
            incomingLight = rayColor * 0.1;
            break;
        }
}

    return incomingLight;
}


[numthreads(16, 16, 1)]
void RayTracer (uint3 id : SV_DispatchThreadID)
{
    // Get the dimensions of the RenderTexture
	uint width, height;
	Result.GetDimensions(width, height);

	// Transform pixel to [-1,1] range
	float2 uv = float2(id.xy  / float2(width, height) * 2.0f - 1.0f);

    uint2 numPixels = _ScreenParams.xy;
    uint2 pixelCoord = id.xy * numPixels;
    uint pixelIndex = pixelCoord.y * numPixels.x + pixelCoord.x;
    uint rngState = pixelIndex + Frame * 719393;

	// Get a ray for the UVs
	Ray ray = CreateCameraRay(uv);

    // Trace a bunch of rays and average the result
    float3 totalIncomingLight = 0;
    const int NumRaysPerPixel = 4;

    for (int rayIndex = 0; rayIndex < NumRaysPerPixel; rayIndex ++)
    {	
        totalIncomingLight += Trace(ray, rngState);
    }

    float3 pixelCol = totalIncomingLight / NumRaysPerPixel;

    Result[id.xy] = float4(pixelCol, 1.0f);
    // Result[id.xy] = float4(rand(rngState), rand(rngState), rand(rngState), 1.0f);

    // RayHit hit = Trace(ray, rngState);
    // if (hit.didHit)
    // {
    //     RayTracingMaterial material = hit.material;
    //     if(material.texID >= 0)
    //     {
    //         float4 texColor = _Texs.SampleLevel(sampler__Texs, float3(hit.texcoord, material.texID), 0);
    //         Result[id.xy] = texColor * material.albedo;
    //     }
    //     else
    //     {
    //         Result[id.xy] = material.albedo;
    //     }
    //     // Result[id.xy] = hit.material.texID / 3.0;
    // }
    // else
    // {
    //     Result[id.xy] = float4(0, 0, 0, 1);
    // }
	
}